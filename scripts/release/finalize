#!/usr/bin/env bash

# run by the release-finalize.yml github action workflow
# * merge MERGE_FROM branch (release/A.B.C)
#   into MERGE_INTO (release/A.B.x or main)
#   * squash release commits if target is main
# * remove generated static files
# * update version in version.go and scripts/release/previous.version

[ -n "$DEBUG" ] && set -x
set -euo pipefail

source "$(dirname "${BASH_SOURCE[0]}")/check-working-dir"

echo 'Checking variables'
  MERGE_FROM="${MERGE_FROM:-$(git branch --show-current)}"
  # vars displayed this way for easier troubleshooting
  cat <<VARS
export NEW_VERSION='${NEW_VERSION?is required}'
export MERGE_INTO='${MERGE_INTO?is required}'
export MERGE_FROM='$MERGE_FROM'
$0

VARS

echo 'Ensuring branches'
  # merge-into second, so we proceed from there.
  for b in "$MERGE_FROM" "$MERGE_INTO"; do
    git fetch origin "$b"
    git switch "$b"
    git pull origin "$b"
  done
echo

# if the target is main, we cherry-pick from the source and call it a day.
if [ "$MERGE_INTO" == "${MAIN_BRANCH:-main}" ]; then
  echo 'Target branch is main; squash-merging release commits'

  # squash to exclude the generated files from git history entirely;
  # they're big, and kept for posterity in other branches.
  # commit messages from release workflows match this pattern.
  msg="^release:.* ${NEW_VERSION}$"
  commits="$(git log --grep "$msg" --reverse --pretty='%H' "$MERGE_FROM")"
  [ -n "$commits" ] || { echo "found no commits for '$msg'"; exit 1; }

  echo "$commits" | xargs git cherry-pick --no-commit || {
    echo "::error::failed to cherry-pick release commits"
    echo -e "commit IDs:\n$commits"
    git status
    git diff --color=always | /bin/cat
    exit 1
  }

  exit # nothing else to do
fi

echo "Merging changes from '$MERGE_FROM' into '$MERGE_INTO'"
  if ! git merge --no-edit "$MERGE_FROM"; then
    echo "::error::failed to merge $MERGE_FROM into $MERGE_INTO"
    git status
    git diff --color=always | /bin/cat
    exit 1
  fi
echo

echo 'Updating magic strings in magic files'
  if [ -n "$(semver get prerel "$NEW_VERSION")" ]; then
    echo "$NEW_VERSION is a prerelease; reverting changelog"
    # we'll re-update changelog for GA.
    git restore --source="origin/$MERGE_INTO" -- CHANGELOG.md

  else
    echo "$NEW_VERSION is not a prerelease; bumping versions"
    next_patch="$(semver bump patch "$NEW_VERSION")"
    sed -i.bak -e "s|\(Version * = *\"\)[^\"]*|\1${next_patch}|g" version/version.go

    # previous version to use next time the changelog is generated
    sed -i.bak "s/^[^#].*/$NEW_VERSION/" scripts/release/previous.version
  fi

  # set VersionPrerelease back to "dev"
  sed -i.bak -e "s|\(VersionPrerelease * = *\"\)[^\"]*|\1dev|g" version/version.go

  rm -f version/version.go.bak scripts/release/previous.version.bak
  git diff --color=always version/version.go scripts/release/previous.version
  git add version/version.go scripts/release/previous.version
echo

echo 'Removing generated static assets'
  # These generated files are only needed when building the final
  # binary and should be not be present in the repository afterwards.
  git rm -f ./{nomad,client}/structs/*.generated.go
echo

# there should be no stray unexpected changes
if ! git diff --color=always --exit-code; then
  git status
  echo "::error::Unexpected changes left unstaged by finalize script"
  exit 1
fi
